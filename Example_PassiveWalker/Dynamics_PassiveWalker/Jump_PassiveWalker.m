function [flow,flowTraj,q,p,s]=Jump_PassiveWalker(flow,t,q,p,u,s,l)
    act=0;
    count=0;
    flowTraj=zeros(100+1,1);
    while(1)
        flowTraj(count+1)=flow;
        act=0;
%SWITCHCASE_

		switch flow
		    case 1
		        [act,flow,count,q,p,s]=Jump_1_2_PassiveWalker(act,flow,count,t,q,p,u,s,l);
		    case 2
		        [act,flow,count,q,p,s]=Jump_2_3_PassiveWalker(act,flow,count,t,q,p,u,s,l);
		    case 3
		        [act,flow,count,q,p,s]=Jump_3_4_PassiveWalker(act,flow,count,t,q,p,u,s,l);
		    case 4
		        [act,flow,count,q,p,s]=Jump_4_5_PassiveWalker(act,flow,count,t,q,p,u,s,l);
		    case 5
		        [act,flow,count,q,p,s]=Jump_5_6_PassiveWalker(act,flow,count,t,q,p,u,s,l);
		    case 6
		        [act,flow,count,q,p,s]=Jump_6_1_PassiveWalker(act,flow,count,t,q,p,u,s,l);
		end

        if(act==0)
            break;
        end
        if(count>100)
            flow=-flow;%Enter zeno or other infinite jump problem, quit and give an error.
            break;
        end
    end

	function MMatrix = MMat(t,in2,in3,in4,NHSIGNAL,in6)
	%MMAT
	%    MMATRIX = MMAT(T,IN2,IN3,IN4,NHSIGNAL,IN6)
	%    This function was generated by the Symbolic Math Toolbox version 7.2.
	%    06-Apr-2018 17:34:54
	qi1__dt_0 = in2(3,:);
	qi2__dt_0 = in2(4,:);
	qo1__dt_0 = in2(5,:);
	qo2__dt_0 = in2(6,:);
	t2 = cos(qi1__dt_0);
	t3 = t2.*(9.0./2.0);
	t4 = sin(qi1__dt_0);
	t5 = t4.*(9.0./2.0);
	t6 = cos(qi2__dt_0);
	t7 = t6.*(7.0./5.0);
	t8 = sin(qi2__dt_0);
	t9 = t8.*(7.0./5.0);
	t10 = qi1__dt_0-qi2__dt_0;
	t11 = cos(t10);
	t12 = t11.*(7.0./1.0e1);
	t13 = cos(qo1__dt_0);
	t14 = t13.*(9.0./2.0);
	t15 = sin(qo1__dt_0);
	t16 = t15.*(9.0./2.0);
	t17 = cos(qo2__dt_0);
	t18 = t17.*(7.0./5.0);
	t19 = sin(qo2__dt_0);
	t20 = t19.*(7.0./5.0);
	t21 = qo1__dt_0-qo2__dt_0;
	t22 = cos(t21);
	t23 = t22.*(7.0./1.0e1);
	MMatrix = reshape([8.6e1,0.0,t3,t7,t14,t18,0.0,8.6e1,t5,t9,t16,t20,t3,t5,3.3e1./2.0e1,t12,0.0,0.0,t7,t9,t12,4.9e1./1.25e2,0.0,0.0,t14,t16,0.0,0.0,3.3e1./2.0e1,t23,t18,t20,0.0,0.0,t23,4.9e1./1.25e2],[6,6]);
	end

	function [act,flow,count,q,p,s]=Jump_1_2_PassiveWalker(act,flow,count,t,q,p,u,s,l)
	    if(act)%If jump occured in previous jump function, return.
	        return;
	    end
	    
	    if((flow==1)&&CONDITION_(act,flow,count,t,q,p,u,s,l))%Condition to determine jump occurence.
	        act=1;%Flag of jumpping
	        flow=2;%The flow after jumping
	        count=count+1;%Counter for Jumping occurence at the same moment
	    else
	        act=0;
	        count=0;
	        return;
	    end
	    
	    [t,q,p,u,s,l]=RESET_(act,flow,count,t,q,p,u,s,l);
	    function [t,q,p,u,s,l]=RESET_(act,flow,count,t,q,p,u,s,l)
	        %The Default Impact Mapper, requires Constraint Jacobian <JCons> and Inertia Matrix <MMat>
	        qSize=numel(q);
	        qdot=q(qSize/2+1:qSize);
	        M=MMat(t,q,p,u,s,l);%Note the input of MMat does not include act, flow, and count!
	        J=JCons(act,flow,count,t,q,p,u,s,l);
	        q(qSize/2+1:qSize)=qdot-(M\(J.'*((J*(M\J.'))\J)))*qdot;
	        %Write Your Reset Map Below!
	        q(6)=q(5);
	        p(2)=LockAngle(act,flow,count,t,q,p,u,s,l);
	    end
	%  
	%     function output=CONDITION_(act,flow,count,t,q,p,u,s,l)
	%           %Write Your Jumping Condition Map Here!
	%     end
		function realExpr = CONDITION_(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%CONDITION_
		%    REALEXPR = CONDITION_(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:47:10
		qo1__dt_0 = in5(5,:);
		qo2__dt_0 = in5(6,:);
		realExpr = (qo1__dt_0 <= qo2__dt_0);
		end
		function realExpr = LockAngle(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%LOCKANGLE
		%    REALEXPR = LOCKANGLE(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:47:10
		qi1__dt_0 = in5(3,:);
		realExpr = qi1__dt_0;
		end
		function realExpr = JCons(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%JCONS
		%    REALEXPR = JCONS(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:47:11
		qi1__dt_0 = in5(3,:);
		qi2__dt_0 = in5(4,:);
		realExpr = reshape([0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,cos(qi1__dt_0).*(1.0./2.0),sin(qi1__dt_0).*(1.0./2.0),0.0,-1.0,cos(qi2__dt_0).*(1.0./2.0),sin(qi2__dt_0).*(1.0./2.0),1.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0],[4,6]);
		end
	end

	function [act,flow,count,q,p,s]=Jump_2_3_PassiveWalker(act,flow,count,t,q,p,u,s,l)
	    if(act)%If jump occured in previous jump function, return.
	        return;
	    end
	    
	    if((flow==2)&&CONDITION_(act,flow,count,t,q,p,u,s,l))%Condition to determine jump occurence.
	        act=1;%Flag of jumpping
	        flow=3;%The flow after jumping
	        count=count+1;%Counter for Jumping occurence at the same moment
	    else
	        act=0;
	        count=0;
	        return;
	    end
	    
	    [t,q,p,u,s,l]=RESET_(act,flow,count,t,q,p,u,s,l);
	    function [t,q,p,u,s,l]=RESET_(act,flow,count,t,q,p,u,s,l)
	        %The Default Impact Mapper, requires Constraint Jacobian <JCons> and Inertia Matrix <MMat>
	        qSize=numel(q);
	        qdot=q(qSize/2+1:qSize);
	        M=MMat(t,q,p,u,s,l);%Note the input of MMat does not include act, flow, and count!
	        J=JCons(act,flow,count,t,q,p,u,s,l);
	        q(qSize/2+1:qSize)=qdot-(M\(J.'*((J*(M\J.'))\J)))*qdot;
	        %Write Your Reset Map Below!
	    end
	%  
	%     function output=CONDITION_(act,flow,count,t,q,p,u,s,l)
	%           %Write Your Jumping Condition Map Here!
	%     end
		function realExpr = CONDITION_(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%CONDITION_
		%    REALEXPR = CONDITION_(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:47:26
		ba = in7(4,:);
		la = in6(2,:);
		qi1__dt_0 = in5(3,:);
		realExpr = (qi1__dt_0+ba <= la);
		end
		function realExpr = JCons(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%JCONS
		%    REALEXPR = JCONS(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:47:27
		qi1__dt_0 = in5(3,:);
		qi2__dt_0 = in5(4,:);
		realExpr = reshape([0.0,1.0,0.0,0.0,0.0,1.0,0.0,cos(qi1__dt_0).*(1.0./2.0),sin(qi1__dt_0).*(1.0./2.0),0.0,cos(qi2__dt_0).*(1.0./2.0),sin(qi2__dt_0).*(1.0./2.0),1.0,0.0,0.0,-1.0,0.0,0.0],[3,6]);
		end
	end

	function [act,flow,count,q,p,s]=Jump_3_4_PassiveWalker(act,flow,count,t,q,p,u,s,l)
	    if(act)%If jump occured in previous jump function, return.
	        return;
	    end
	    
	    if((flow==3)&&CONDITION_(act,flow,count,t,q,p,u,s,l))%Condition to determine jump occurence.
	        act=1;%Flag of jumpping
	        flow=4;%The flow after jumping
	        count=count+1;%Counter for Jumping occurence at the same moment
	    else
	        act=0;
	        count=0;
	        return;
	    end
	    
	    [t,q,p,u,s,l]=RESET_(act,flow,count,t,q,p,u,s,l);
	    function [t,q,p,u,s,l]=RESET_(act,flow,count,t,q,p,u,s,l)
	        %The Default Impact Mapper, requires Constraint Jacobian <JCons> and Inertia Matrix <MMat>
	        qSize=numel(q);
	        qdot=q(qSize/2+1:qSize);
	        M=MMat(t,q,p,u,s,l);%Note the input of MMat does not include act, flow, and count!
	        J=JCons(act,flow,count,t,q,p,u,s,l);
	        q(qSize/2+1:qSize)=qdot-(M\(J.'*((J*(M\J.'))\J)))*qdot;
	        %Write Your Reset Map Below!
	        q(2)=YReal(act,flow,count,t,q,p,u,s,l);
	        p(1)=FPos(act,flow,count,t,q,p,u,s,l);
	    end
	%  
	%     function output=CONDITION_(act,flow,count,t,q,p,u,s,l)
	%           %Write Your Jumping Condition Map Here!
	%     end
		function realExpr = CONDITION_(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%CONDITION_
		%    REALEXPR = CONDITION_(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:47:42
		qo1__dt_0 = in5(5,:);
		qo2__dt_0 = in5(6,:);
		qy__dt_0 = in5(2,:);
		realExpr = (qy__dt_0.*2.0 <= cos(qo1__dt_0)+cos(qo2__dt_0));
		end
		function realExpr = FPos(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%FPOS
		%    REALEXPR = FPOS(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:47:42
		qo1__dt_0 = in5(5,:);
		qo2__dt_0 = in5(6,:);
		qx__dt_0 = in5(1,:);
		realExpr = qx__dt_0+sin(qo1__dt_0).*(1.0./2.0)+sin(qo2__dt_0).*(1.0./2.0);
		end
		function realExpr = YReal(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%YREAL
		%    REALEXPR = YREAL(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:47:42
		qo1__dt_0 = in5(5,:);
		qo2__dt_0 = in5(6,:);
		realExpr = cos(qo1__dt_0).*(1.0./2.0)+cos(qo2__dt_0).*(1.0./2.0);
		end
		function realExpr = JCons(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%JCONS
		%    REALEXPR = JCONS(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:47:42
		qo1__dt_0 = in5(5,:);
		qo2__dt_0 = in5(6,:);
		realExpr = reshape([0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,cos(qo1__dt_0).*(1.0./2.0),sin(qo1__dt_0).*(1.0./2.0),-1.0,cos(qo2__dt_0).*(1.0./2.0),sin(qo2__dt_0).*(1.0./2.0)],[3,6]);
		end
	end

	function [act,flow,count,q,p,s]=Jump_4_5_PassiveWalker(act,flow,count,t,q,p,u,s,l)
	    if(act)%If jump occured in previous jump function, return.
	        return;
	    end
	    
	    if((flow==4)&&CONDITION_(act,flow,count,t,q,p,u,s,l))%Condition to determine jump occurence.
	        act=1;%Flag of jumpping
	        flow=5;%The flow after jumping
	        count=count+1;%Counter for Jumping occurence at the same moment
	    else
	        act=0;
	        count=0;
	        return;
	    end
	    
	    [t,q,p,u,s,l]=RESET_(act,flow,count,t,q,p,u,s,l);
	    function [t,q,p,u,s,l]=RESET_(act,flow,count,t,q,p,u,s,l)
	        %The Default Impact Mapper, requires Constraint Jacobian <JCons> and Inertia Matrix <MMat>
	        qSize=numel(q);
	        qdot=q(qSize/2+1:qSize);
	        M=MMat(t,q,p,u,s,l);%Note the input of MMat does not include act, flow, and count!
	        J=JCons(act,flow,count,t,q,p,u,s,l);
	        q(qSize/2+1:qSize)=qdot-(M\(J.'*((J*(M\J.'))\J)))*qdot;
	        %Write Your Reset Map Below!
	        q(4)=q(3);
	        p(2)=LockAngle(act,flow,count,t,q,p,u,s,l);
	    end
	%  
	%     function output=CONDITION_(act,flow,count,t,q,p,u,s,l)
	%           %Write Your Jumping Condition Map Here!
	%     end
		function realExpr = CONDITION_(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%CONDITION_
		%    REALEXPR = CONDITION_(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:47:59
		qi1__dt_0 = in5(3,:);
		qi2__dt_0 = in5(4,:);
		realExpr = (qi1__dt_0 <= qi2__dt_0);
		end
		function realExpr = LockAngle(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%LOCKANGLE
		%    REALEXPR = LOCKANGLE(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:47:59
		qo1__dt_0 = in5(5,:);
		realExpr = qo1__dt_0;
		end
		function realExpr = JCons(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%JCONS
		%    REALEXPR = JCONS(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:47:59
		qo1__dt_0 = in5(5,:);
		qo2__dt_0 = in5(6,:);
		realExpr = reshape([0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0,0.0,1.0,cos(qo1__dt_0).*(1.0./2.0),sin(qo1__dt_0).*(1.0./2.0),0.0,-1.0,cos(qo2__dt_0).*(1.0./2.0),sin(qo2__dt_0).*(1.0./2.0)],[4,6]);
		end
	end

	function [act,flow,count,q,p,s]=Jump_5_6_PassiveWalker(act,flow,count,t,q,p,u,s,l)
	    if(act)%If jump occured in previous jump function, return.
	        return;
	    end
	    
	    if((flow==5)&&CONDITION_(act,flow,count,t,q,p,u,s,l))%Condition to determine jump occurence.
	        act=1;%Flag of jumpping
	        flow=6;%The flow after jumping
	        count=count+1;%Counter for Jumping occurence at the same moment
	    else
	        act=0;
	        count=0;
	        return;
	    end
	    
	    [t,q,p,u,s,l]=RESET_(act,flow,count,t,q,p,u,s,l);
	    function [t,q,p,u,s,l]=RESET_(act,flow,count,t,q,p,u,s,l)
	        %The Default Impact Mapper, requires Constraint Jacobian <JCons> and Inertia Matrix <MMat>
	        qSize=numel(q);
	        qdot=q(qSize/2+1:qSize);
	        M=MMat(t,q,p,u,s,l);%Note the input of MMat does not include act, flow, and count!
	        J=JCons(act,flow,count,t,q,p,u,s,l);
	        q(qSize/2+1:qSize)=qdot-(M\(J.'*((J*(M\J.'))\J)))*qdot;
	        %Write Your Reset Map Below!
	    end
	%  
	%     function output=CONDITION_(act,flow,count,t,q,p,u,s,l)
	%           %Write Your Jumping Condition Map Here!
	%     end
		function realExpr = CONDITION_(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%CONDITION_
		%    REALEXPR = CONDITION_(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:48:14
		ba = in7(4,:);
		la = in6(2,:);
		qo1__dt_0 = in5(5,:);
		realExpr = (qo1__dt_0+ba <= la);
		end
		function realExpr = JCons(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%JCONS
		%    REALEXPR = JCONS(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:48:14
		qo1__dt_0 = in5(5,:);
		qo2__dt_0 = in5(6,:);
		realExpr = reshape([0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,-1.0,0.0,0.0,0.0,cos(qo1__dt_0).*(1.0./2.0),sin(qo1__dt_0).*(1.0./2.0),0.0,cos(qo2__dt_0).*(1.0./2.0),sin(qo2__dt_0).*(1.0./2.0)],[3,6]);
		end
	end

	function [act,flow,count,q,p,s]=Jump_6_1_PassiveWalker(act,flow,count,t,q,p,u,s,l)
	    if(act)%If jump occured in previous jump function, return.
	        return;
	    end
	    
	    if((flow==6)&&CONDITION_(act,flow,count,t,q,p,u,s,l))%Condition to determine jump occurence.
	        act=1;%Flag of jumpping
	        flow=1;%The flow after jumping
	        count=count+1;%Counter for Jumping occurence at the same moment
	    else
	        act=0;
	        count=0;
	        return;
	    end
	    
	    [t,q,p,u,s,l]=RESET_(act,flow,count,t,q,p,u,s,l);
	    function [t,q,p,u,s,l]=RESET_(act,flow,count,t,q,p,u,s,l)
	        %The Default Impact Mapper, requires Constraint Jacobian <JCons> and Inertia Matrix <MMat>
	        qSize=numel(q);
	        qdot=q(qSize/2+1:qSize);
	        M=MMat(t,q,p,u,s,l);%Note the input of MMat does not include act, flow, and count!
	        J=JCons(act,flow,count,t,q,p,u,s,l);
	        q(qSize/2+1:qSize)=qdot-(M\(J.'*((J*(M\J.'))\J)))*qdot;
	        %Write Your Reset Map Below!
	        q(2)=YReal(act,flow,count,t,q,p,u,s,l);
	        p(1)=FPos(act,flow,count,t,q,p,u,s,l);
	    end
	%  
	%     function output=CONDITION_(act,flow,count,t,q,p,u,s,l)
	%           %Write Your Jumping Condition Map Here!
	%     end
		function realExpr = CONDITION_(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%CONDITION_
		%    REALEXPR = CONDITION_(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:48:30
		qi1__dt_0 = in5(3,:);
		qi2__dt_0 = in5(4,:);
		qy__dt_0 = in5(2,:);
		realExpr = (qy__dt_0.*2.0 <= cos(qi1__dt_0)+cos(qi2__dt_0));
		end
		function realExpr = FPos(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%FPOS
		%    REALEXPR = FPOS(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:48:30
		qi1__dt_0 = in5(3,:);
		qi2__dt_0 = in5(4,:);
		qx__dt_0 = in5(1,:);
		realExpr = qx__dt_0+sin(qi1__dt_0).*(1.0./2.0)+sin(qi2__dt_0).*(1.0./2.0);
		end
		function realExpr = YReal(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%YREAL
		%    REALEXPR = YREAL(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:48:30
		qi1__dt_0 = in5(3,:);
		qi2__dt_0 = in5(4,:);
		realExpr = cos(qi1__dt_0).*(1.0./2.0)+cos(qi2__dt_0).*(1.0./2.0);
		end
		function realExpr = JCons(ACT,FLOW,COUNT,t,in5,in6,in7,NHSIGNAL,in9)
		%JCONS
		%    REALEXPR = JCONS(ACT,FLOW,COUNT,T,IN5,IN6,IN7,NHSIGNAL,IN9)
		%    This function was generated by the Symbolic Math Toolbox version 8.0.
		%    31-Mar-2018 04:48:30
		qi1__dt_0 = in5(3,:);
		qi2__dt_0 = in5(4,:);
		realExpr = reshape([0.0,1.0,0.0,0.0,0.0,1.0,1.0,cos(qi1__dt_0).*(1.0./2.0),sin(qi1__dt_0).*(1.0./2.0),-1.0,cos(qi2__dt_0).*(1.0./2.0),sin(qi2__dt_0).*(1.0./2.0),0.0,0.0,0.0,0.0,0.0,0.0],[3,6]);
		end
	end

end

